package controller

import (
	"net/http"

	"github.com/labstack/echo/v4"
	"github.com/robstave/meowmorize/internal/domain/types"
)

// CreateDeck handles the creation of a new deck
// @Summary Create a new deck
// @Description Create a new deck with provided details
// @Tags Decks
// @Accept  json
// @Produce  json
// @Param deck body types.Deck true "Deck to create"
// @Success 201 {object} types.Deck
// @Failure 400 {object} map[string]string
// @Failure 500 {object} map[string]string
// @Router /decks [post]
func (hc *MeowController) CreateDeck(c echo.Context) error {
	var deck types.Deck
	if err := c.Bind(&deck); err != nil {
		hc.logger.Error("Failed to bind deck data", "error", err)
		return c.JSON(http.StatusBadRequest, echo.Map{
			"message": "Invalid deck data",
		})
	}

	if err := hc.service.CreateDeck(deck); err != nil {
		hc.logger.Error("Failed to create deck", "error", err)
		return c.JSON(http.StatusInternalServerError, echo.Map{
			"message": "Failed to create deck",
		})
	}

	return c.JSON(http.StatusCreated, deck)
}

// CreateDeck handles the creation of a new deck
// @Summary Create a default deck
// @Description Create a new deck with provided details
// @Tags Decks
// @Accept  json
// @Produce  json
// @Param deck body types.Deck true "Deck to create"
// @Success 201 {object} types.Deck
// @Failure 400 {object} map[string]string
// @Failure 500 {object} map[string]string
// @Router /decks/default [post]
func (hc *MeowController) CreateDefaultDeck(c echo.Context) error {
	hc.logger.Info("Creating default deck")

	if err := hc.service.CreateDefaultDeck(); err != nil {
		hc.logger.Error("Failed to create default deck", "error", err)
		return c.JSON(http.StatusInternalServerError, echo.Map{
			"message": "Failed to create default deck",
		})
	}

	return c.JSON(http.StatusCreated, echo.Map{
		"message": "created default deck",
	})
}

// DeleteDeck handles the deletion of a deck
// @Summary Delete a deck
// @Description Delete a deck by its ID
// @Tags Decks
// @Param id path string true "Deck ID"
// @Success 200 {object} map[string]string
// @Failure 400 {object} map[string]string
// @Failure 404 {object} map[string]string
// @Failure 500 {object} map[string]string
// @Router /decks/{id} [delete]
func (hc *MeowController) DeleteDeck(c echo.Context) error {
	deckID := c.Param("id")

	// Perform deletion
	err := hc.service.DeleteDeck(deckID)
	if err != nil {
		hc.logger.Error("Failed to delete deck", "error", err)
		return c.JSON(http.StatusInternalServerError, echo.Map{
			"message": "Failed to delete deck",
		})
	}

	return c.JSON(http.StatusOK, echo.Map{
		"message": "Deck deleted successfully",
	})
}

// GetAllDecks retrieves all decks
// @Summary Get all decks
// @Description Retrieve a list of all decks
// @Tags Decks
// @Produce  json
// @Success 200 {array} types.Deck
// @Failure 500 {object} map[string]string
// @Router /decks [get]
func (hc *MeowController) GetAllDecks(c echo.Context) error {
	decks, err := hc.service.GetAllDecks()
	if err != nil {
		hc.logger.Error("Failed to retrieve decks", "error", err)
		return c.JSON(http.StatusInternalServerError, echo.Map{
			"message": "Failed to retrieve decks",
		})
	}

	return c.JSON(http.StatusOK, decks)
}

// GetDeckByID retrieves a deck by its ID
// @Summary Get a deck by ID
// @Description Retrieve a single deck by its ID
// @Tags Decks
// @Produce  json
// @Param id path string true "Deck ID"
// @Success 200 {object} types.Deck
// @Failure 400 {object} map[string]string
// @Failure 404 {object} map[string]string
// @Failure 500 {object} map[string]string
// @Router /decks/{id} [get]
func (hc *MeowController) GetDeckByID(c echo.Context) error {
	deckID := c.Param("id")

	deck, err := hc.service.GetDeckByID(deckID)
	if err != nil {
		hc.logger.Error("Failed to get deck by ID", "error", err)
		return c.JSON(http.StatusInternalServerError, echo.Map{
			"message": "Failed to retrieve deck",
		})
	}

	//if (deck == types.Deck{}) {
	//	return c.JSON(http.StatusNotFound, echo.Map{
	//		"message": "Deck not found",
	//	})
	//}

	return c.JSON(http.StatusOK, deck)
}

// UpdateDeck handles updating an existing deck
// @Summary Update a deck
// @Description Update an existing deck by its ID
// @Tags Decks
// @Accept  json
// @Produce  json
// @Param id path string true "Deck ID"
// @Param deck body types.Deck true "Updated Deck"
// @Success 200 {object} types.Deck
// @Failure 400 {object} map[string]string
// @Failure 404 {object} map[string]string
// @Failure 500 {object} map[string]string
// @Router /decks/{id} [put]
func (hc *MeowController) UpdateDeck(c echo.Context) error {
	deckID := c.Param("id")
	var updatedDeck types.Deck

	if err := c.Bind(&updatedDeck); err != nil {
		hc.logger.Error("Failed to bind deck data", "error", err)
		return c.JSON(http.StatusBadRequest, echo.Map{
			"message": "Invalid deck data",
		})
	}

	// Ensure the ID in the path matches the ID in the payload
	if updatedDeck.ID != deckID {
		return c.JSON(http.StatusBadRequest, echo.Map{
			"message": "Deck ID mismatch",
		})
	}

	if err := hc.service.UpdateDeck(updatedDeck); err != nil {
		hc.logger.Error("Failed to update deck", "error", err)
		return c.JSON(http.StatusInternalServerError, echo.Map{
			"message": "Failed to update deck",
		})
	}

	return c.JSON(http.StatusOK, updatedDeck)
}


=== End of internal/adapters/controller/deck.go ===

package controller

import (
	"log/slog"

	"github.com/robstave/meowmorize/internal/domain"
)

type MeowController struct {
	service domain.MeowDomain
	logger  *slog.Logger
}

func NewMeowController(service domain.MeowDomain, logger *slog.Logger) *MeowController {
	return &MeowController{service: service, logger: logger}
}


=== End of internal/adapters/controller/controller.go ===

// internal/adapters/controller/import.go

package controller

import (
	"encoding/json"
	"net/http"

	"github.com/labstack/echo/v4"
	"github.com/robstave/meowmorize/internal/domain/types"
)

// ImportDeck handles the import deck POST request
// @Summary Import a deck from a JSON file
// @Description Import a new deck by uploading a JSON file
// @Tags Decks
// @Accept multipart/form-data
// @Produce json
// @Param deck_file formData file true "Deck JSON File"
// @Success 201 {object} types.Deck
// @Failure 400 {object} map[string]string
// @Failure 500 {object} map[string]string
// @Router /decks/import [post]
func (hc *MeowController) ImportDeck(c echo.Context) error {

	// Read JSON from file upload
	file, err := c.FormFile("deck_file")
	if err != nil {
		hc.logger.Error("Failed to read deck file", "error", err)
		return c.JSON(http.StatusBadRequest, echo.Map{
			"message": "Deck file is required",
		})
	}

	src, err := file.Open()
	if err != nil {
		hc.logger.Error("Failed to open file", "error", err)
		return c.JSON(http.StatusInternalServerError, echo.Map{
			"message": "Failed to open deck file",
		})
	}
	defer src.Close()

	var deckData struct {
		Deck types.Deck `json:"deck"`
	}

	hc.logger.Info("Decoding deck JSON")

	if err := json.NewDecoder(src).Decode(&deckData); err != nil {
		hc.logger.Error("JSON decoding failed", "error", err)
		return c.JSON(http.StatusBadRequest, echo.Map{
			"message": "Invalid JSON format",
		})
	}

	// Logging for debugging
	hc.logger.Info("Imported deck", "id", deckData.Deck.ID, "name", deckData.Deck.Name,
		"number_of_cards", len(deckData.Deck.Cards))

	for _, card := range deckData.Deck.Cards {
		if card.ID == "" || card.DeckID == "" || card.Front.Text == "" || card.Back.Text == "" {
			hc.logger.Warn("Incomplete card data", "card", card)
		} else {
			hc.logger.Info("Imported Card",
				"uuid", card.ID,
				"did", card.DeckID,
				"front", card.Front.Text,
				"back", card.Back.Text)
		}
	}

	// Assign DeckID to each card if not already set
	for i := range deckData.Deck.Cards {
		if deckData.Deck.Cards[i].DeckID == "" {
			deckData.Deck.Cards[i].DeckID = deckData.Deck.ID
		}
	}

	// Save the deck to the database
	if err := hc.service.CreateDeck(deckData.Deck); err != nil {
		hc.logger.Error("Failed to save deck", "error", err)
		return c.JSON(http.StatusInternalServerError, echo.Map{
			"message": "Failed to save deck",
		})
	}

	hc.logger.Info("Deck imported successfully", "id", deckData.Deck.ID)

	return c.JSON(http.StatusCreated, deckData.Deck)
}


=== End of internal/adapters/controller/import.go ===

package repositories

import (
	"github.com/robstave/meowmorize/internal/domain/types"

	"gorm.io/gorm"
)

type CardRepository interface {
	GetCardsByDeckID(deckID string) ([]types.Card, error)
	CreateCard(card types.Card) error
}

type CardRepositorySQLite struct {
	db *gorm.DB
}

func NewCardRepositorySQLite(db *gorm.DB) CardRepository {
	return &CardRepositorySQLite{db: db}
}

func (r *CardRepositorySQLite) GetCardsByDeckID(deckID string) ([]types.Card, error) {
	var cards []types.Card
	if err := r.db.Where("deck_id = ?", deckID).Find(&cards).Error; err != nil {
		return nil, err
	}
	return cards, nil
}

func (r *CardRepositorySQLite) CreateCard(card types.Card) error {
	return r.db.Create(&card).Error
}


=== End of internal/adapters/repositories/card.go ===

package repositories

import (
	"github.com/robstave/meowmorize/internal/domain/types"

	"gorm.io/gorm"
)

type DeckRepository interface {
	GetAllDecks() ([]types.Deck, error)
	CreateDeck(deck types.Deck) error
	DeleteDeck(deckID string) error
	GetDeckByID(deckID string) (types.Deck, error)
	UpdateDeck(deck types.Deck) error // New method
}

type DeckRepositorySQLite struct {
	db *gorm.DB
}

func NewDeckRepositorySQLite(db *gorm.DB) DeckRepository {
	return &DeckRepositorySQLite{db: db}
}

func (r *DeckRepositorySQLite) GetAllDecks() ([]types.Deck, error) {
	var decks []types.Deck
	if err := r.db.Preload("Cards").Find(&decks).Error; err != nil {
		return nil, err
	}
	return decks, nil
}

func (r *DeckRepositorySQLite) CreateDeck(deck types.Deck) error {
	return r.db.Create(&deck).Error
}

func (r *DeckRepositorySQLite) GetDeckByID(deckID string) (types.Deck, error) {
	var deck types.Deck
	if err := r.db.Preload("Cards").Where("id = ?", deckID).First(&deck).Error; err != nil {
		return types.Deck{}, err
	}
	return deck, nil
}

func (r *DeckRepositorySQLite) DeleteDeck(deckID string) error {
	// Begin a transaction to ensure both deck and its cards are deleted atomically
	tx := r.db.Begin()
	if tx.Error != nil {
		return tx.Error
	}

	// Delete associated cards first to maintain referential integrity
	if err := tx.Where("deck_id = ?", deckID).Delete(&types.Card{}).Error; err != nil {
		tx.Rollback()
		return err
	}

	// Delete the deck
	if err := tx.Where("id = ?", deckID).Delete(&types.Deck{}).Error; err != nil {
		tx.Rollback()
		return err
	}

	// Commit the transaction
	return tx.Commit().Error
}

func (r *DeckRepositorySQLite) UpdateDeck(deck types.Deck) error {
	return r.db.Save(&deck).Error
}


=== End of internal/adapters/repositories/deck.go ===

